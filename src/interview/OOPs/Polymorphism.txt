I'll provide you with a comprehensive explanation of polymorphism, similar to how I explained the Diamond Problem and composition. Let me create a detailed guide for your interview preparation.

Ran tool
## Polymorphism in Java - Complete Interview Guide

### What is Polymorphism?

**Polymorphism** means "many forms" - it's the ability of an object to take on many forms. In Java, it allows one interface to be used for a general class of actions, with the specific action determined by the exact nature of the situation.

### Key Concept:
- **Same interface, different implementations**
- **One method call, different behaviors**
- **Runtime decision making**

## Types of Polymorphism in Java:

### 1. **Compile-Time Polymorphism (Method Overloading)**
- Also called **Static Polymorphism**
- Method resolution happens at **compile time**
- Same method name, different parameters

### 2. **Runtime Polymorphism (Method Overriding)**
- Also called **Dynamic Polymorphism**
- Method resolution happens at **runtime**
- Same method signature, different classes

---

## 1. Compile-Time Polymorphism Example:

```java
class Calculator {
    // Method overloading - same name, different parameters
    public int add(int a, int b) {
        System.out.println("Adding two integers");
        return a + b;
    }
    
    public double add(double a, double b) {
        System.out.println("Adding two doubles");
        return a + b;
    }
    
    public int add(int a, int b, int c) {
        System.out.println("Adding three integers");
        return a + b + c;
    }
    
    public String add(String a, String b) {
        System.out.println("Adding two strings");
        return a + b;
    }
}

public class CompileTimePolymorphism {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        
        // Compiler decides which method to call based on parameters
        System.out.println(calc.add(5, 3));           // Calls int add(int, int)
        System.out.println(calc.add(5.5, 3.2));       // Calls double add(double, double)
        System.out.println(calc.add(1, 2, 3));        // Calls int add(int, int, int)
        System.out.println(calc.add("Hello", "World")); // Calls String add(String, String)
    }
}
```

**Output:**
```
Adding two integers
8
Adding two doubles
8.7
Adding three integers
6
Adding two strings
HelloWorld
```

---

## 2. Runtime Polymorphism Example:

```java
// Base class
class Animal {
    public void makeSound() {
        System.out.println("Animal makes a sound");
    }
    
    public void move() {
        System.out.println("Animal moves");
    }
}

// Derived classes
class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Dog barks: Woof! Woof!");
    }
    
    @Override
    public void move() {
        System.out.println("Dog runs on four legs");
    }
}

class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Cat meows: Meow! Meow!");
    }
    
    @Override
    public void move() {
        System.out.println("Cat walks silently");
    }
}

class Bird extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Bird chirps: Tweet! Tweet!");
    }
    
    @Override
    public void move() {
        System.out.println("Bird flies in the sky");
    }
}

public class RuntimePolymorphism {
    public static void main(String[] args) {
        // Runtime polymorphism - same reference, different objects
        Animal animal1 = new Dog();    // Animal reference, Dog object
        Animal animal2 = new Cat();    // Animal reference, Cat object
        Animal animal3 = new Bird();   // Animal reference, Bird object
        
        // Same method call, different behaviors (decided at runtime)
        animal1.makeSound();  // Calls Dog's makeSound()
        animal1.move();       // Calls Dog's move()
        
        animal2.makeSound();  // Calls Cat's makeSound()
        animal2.move();       // Calls Cat's move()
        
        animal3.makeSound();  // Calls Bird's makeSound()
        animal3.move();       // Calls Bird's move()
        
        // Polymorphism with arrays
        Animal[] animals = {new Dog(), new Cat(), new Bird()};
        
        System.out.println("\n--- All animals making sounds ---");
        for (Animal animal : animals) {
            animal.makeSound();  // Different sound for each animal
        }
    }
}
```

**Output:**
```
Dog barks: Woof! Woof!
Dog runs on four legs
Cat meows: Meow! Meow!
Cat walks silently
Bird chirps: Tweet! Tweet!
Bird flies in the sky

--- All animals making sounds ---
Dog barks: Woof! Woof!
Cat meows: Meow! Meow!
Bird chirps: Tweet! Tweet!
```

---

## Real-World Polymorphism Example:

```java
// Shape hierarchy
abstract class Shape {
    protected String color;
    
    public Shape(String color) {
        this.color = color;
    }
    
    // Abstract method - must be implemented by subclasses
    public abstract double calculateArea();
    public abstract double calculatePerimeter();
    
    public void displayInfo() {
        System.out.println("Color: " + color);
    }
}

class Circle extends Shape {
    private double radius;
    
    public Circle(String color, double radius) {
        super(color);
        this.radius = radius;
    }
    
    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
    
    @Override
    public double calculatePerimeter() {
        return 2 * Math.PI * radius;
    }
}

class Rectangle extends Shape {
    private double length, width;
    
    public Rectangle(String color, double length, double width) {
        super(color);
        this.length = length;
        this.width = width;
    }
    
    @Override
    public double calculateArea() {
        return length * width;
    }
    
    @Override
    public double calculatePerimeter() {
        return 2 * (length + width);
    }
}

class Triangle extends Shape {
    private double base, height, side1, side2;
    
    public Triangle(String color, double base, double height, double side1, double side2) {
        super(color);
        this.base = base;
        this.height = height;
        this.side1 = side1;
        this.side2 = side2;
    }
    
    @Override
    public double calculateArea() {
        return 0.5 * base * height;
    }
    
    @Override
    public double calculatePerimeter() {
        return base + side1 + side2;
    }
}

public class ShapePolymorphism {
    public static void main(String[] args) {
        // Polymorphic array - different shapes, same interface
        Shape[] shapes = {
            new Circle("Red", 5.0),
            new Rectangle("Blue", 4.0, 6.0),
            new Triangle("Green", 3.0, 4.0, 5.0, 4.0)
        };
        
        // Same method calls, different implementations
        for (Shape shape : shapes) {
            shape.displayInfo();
            System.out.println("Area: " + shape.calculateArea());
            System.out.println("Perimeter: " + shape.calculatePerimeter());
            System.out.println("---");
        }
    }
}
```

---

## Common Interview Questions & Answers:

### **1. What is polymorphism in Java?**
- **Answer**: Polymorphism allows objects of different types to be treated as objects of a common base type. Same interface, different implementations.

### **2. What are the types of polymorphism?**
- **Answer**: 
  - **Compile-time**: Method overloading (static binding)
  - **Runtime**: Method overriding (dynamic binding)

### **3. What is method overriding vs method overloading?**
- **Overriding**: Same signature, different classes, runtime polymorphism
- **Overloading**: Different signatures, same class, compile-time polymorphism

### **4. Can you override a static method?**
- **Answer**: No, static methods cannot be overridden. They can only be hidden.

### **5. What is the difference between static and dynamic binding?**
- **Static**: Method resolution at compile time (overloading)
- **Dynamic**: Method resolution at runtime (overriding)

### **6. What is the @Override annotation?**
- **Answer**: Optional annotation that helps catch errors at compile time if you're not actually overriding a method.

### **7. Can you achieve polymorphism without inheritance?**
- **Answer**: Yes, through interfaces and method overloading.

### **8. What is the advantage of polymorphism?**
- **Answer**: 
  - Code reusability
  - Flexibility
  - Maintainability
  - Extensibility

---

## Key Points for Your Interview:

1. **Definition**: "Many forms" - same interface, different implementations
2. **Types**: Compile-time (overloading) and Runtime (overriding)
3. **Benefits**: Code reusability, flexibility, maintainability
4. **Real-world**: Think of shapes, animals, or any hierarchy
5. **Implementation**: Use inheritance and interfaces

Ran tool
This comprehensive guide covers all the essential polymorphism concepts you'll need for your Java interview. The examples progress from simple to complex, showing both compile-time and runtime polymorphism in action. The real-world shape example demonstrates how polymorphism makes code more flexible and maintainable!